#include "imports/stdlib.fc";

(slice, cell, int) load_data() inline {
    slice ds = get_data().begin_parse();
    return (ds~load_msg_addr(), ds~load_dict(), ds.slice_empty?() ? 0 : ds.preload_uint(32));
}

() store_data(slice admin_address, cell users, int total_share) impure inline {
    set_data(
        begin_cell()
            .store_slice(admin_address)
            .store_dict(users)
            .store_uint(total_share, 32)
            .end_cell()
    );
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    (slice admin_address, cell users, int total_share) = load_data();
    slice cs = in_msg.begin_parse().skip_bits(4);
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    in_msg_body~skip_bits(64);
    if (op == 0x368ddef3) {
        throw_unless(120, equal_slices(sender_address, admin_address));

        slice s = in_msg_body~load_msg_addr();
        (_, int address) = s.parse_std_addr();
        int share = in_msg_body.preload_uint(32);
        
        (slice us, int success) = users.udict_get?(256, address);

        users~udict_set_builder(256, address, begin_cell().store_uint(share, 32));
        store_data(
            admin_address,
            users,
            (success ? total_share - us.preload_uint(32) : total_share) + share
        );
    } elseif (op == 0x278205c8) {
        throw_unless(120, equal_slices(sender_address, admin_address));

        slice s = in_msg_body~load_msg_addr();
        (_, int address) = s.parse_std_addr();

        (slice us, int success) = users~udict_delete_get?(256, address);
        throw_unless(121, success);

        store_data(
            admin_address,
            users,
            total_share - us.preload_uint(32)
        );
    } elseif (op == 0x068530b3) {
        throw_if(122, users.dict_empty?());

        (int key, slice val, int flag) = users.udict_get_min?(256);
        while (flag) {
            send_raw_message(
                begin_cell()
                    .store_uint(0x10, 6)
                    .store_uint(4, 3)
                    .store_uint(0, 8)
                    .store_uint(key, 256)
                    .store_coins(muldiv(val~load_uint(32), msg_value, total_share))
                    .store_uint(0, 107)
                    .end_cell(),
                1
            );
            
            (key, val, flag) = users.udict_get_next?(256, key);
        }
    } else {
        throw_if(122, users.dict_empty?());

        int amount = in_msg_body~load_coins();
        
        (int key, slice val, int flag) = users.udict_get_min?(256);
        while (flag) {
            send_raw_message(
                begin_cell()
                    .store_uint(0x10, 6)
                    .store_slice(sender_address)
                    .store_coins(20000000)
                    .store_uint(1, 107)
                    .store_ref(
                        begin_cell()
                            .store_uint(0x0f8a7ea5, 32)
                            .store_uint(0, 64)
                            .store_coins(muldiv(val~load_uint(32), amount, total_share))
                            .store_uint(4, 3)
                            .store_uint(0, 8)
                            .store_uint(key, 256)
                            .store_uint(4, 3)
                            .store_uint(0, 8)
                            .store_uint(key, 256)
                            .store_uint(0, 1)
                            .store_coins(1)
                            .store_uint(0, 1)
                            .end_cell()
                    )
                    .end_cell(),
                1
            );

            (key, val, flag) = users.udict_get_next?(256, key);
        }
    }
}

cell load_users() inline {
    slice ds = get_data().begin_parse();
    ds~load_msg_addr();
    return ds.preload_dict();
}

cell get_users() method_id {
    return load_users();
}

int get_user_share(slice user_address) method_id {
    (_, int address) = user_address.parse_std_addr();
    (slice us, _) = load_users().udict_get?(256, address);
    return us.preload_uint(32);
}