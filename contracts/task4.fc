#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";

() recv_internal() impure {
    
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    set_gas_limit(10000000000);

    cell unvis = new_dict();
    cell info = new_dict();
    int si = 0;
    int sj = 0;
    int i = 0;
    while (i < n) {
        tuple row = maze.at(i);
        int j = 0;
        while (j < m) {
            int x = row.at(j);
            if (x == "S"u) {
                si = i;
                sj = j;
                unvis~udict_set_builder(40, i * 31 + j, begin_cell());
                info~udict_set_builder(10, i * 31 + j, begin_cell().store_uint(0, 30));
            } else {
                unvis~udict_set_builder(40, 961 * 961 * 961 * 31 * 31 + i * 31 + j, begin_cell());
                info~udict_set_builder(10, i * 31 + j, begin_cell().store_uint(961 * 961 * 961, 30));
            }
            j += 1;
        }
        i += 1;
    }
    
    int i = 0;
    int j = 0;
    do {
        (int key, _, _) = unvis~udict::delete_get_min(40);
        i = key / 31 % 31;
        j = key % 31;

        tuple deltas = to_tuple([[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]);
        int idx = 0;
        while (idx < 8) {
            (int di, int dj) = deltas.at(idx).unpair();
            int ni = i + di;
            int nj = j + dj;
            if ((ni >= 0) & (ni < n) & (nj >= 0) & (nj < m)) {
                int x = maze.at(ni).at(nj);
                int nkey = key / 961 * 961 + 31 * 31 + ni * 31 + nj;
                if (x == "?"u) {
                    nkey += 961 * 31 * 31;
                } elseif (x == "X"u) {
                    nkey += 961 * 961 * 31 * 31;
                }
                int index = ni * 31 + nj;
                (slice s, _) = info.udict_get?(10, index);
                int oldkey = s.preload_uint(30) * 31 * 31 + index;
                if (nkey < oldkey) {
                    unvis~udict_delete?(40, oldkey);
                    unvis~udict_set_builder(40, nkey, begin_cell());
                    info~udict_replace_builder?(10, index, begin_cell().store_uint(nkey / 961, 30).store_uint(i, 5).store_uint(j, 5));
                }
            }
            idx += 1;
        }
    } until (maze.at(i).at(j) == "E"u);

    cell ans_dict = new_dict();

    int e = i * 31 + j;
    do {
        ans_dict~udict_set_builder(10, i * 31 + j, begin_cell());

        (slice s, _) = info.udict_get?(10, i * 31 + j);
        s~skip_bits(30);
        i = s~load_uint(5);
        j = s.preload_uint(5);
    } until (maze.at(i).at(j) == "S"u);
    ans_dict~udict_delete?(10, e);

    tuple ans = empty_tuple();
    int i = 0;
    while (i < n) {
        tuple maze_row = maze.at(i);
        tuple row = empty_tuple();
        int j = 0;
        while (j < m) {
            (_, int success) = ans_dict.udict_get?(10, i * 31 + j);
            row~tpush(success ? "!"u : maze_row.at(j));
            j += 1;
        }
        ans~tpush(row);
        i += 1;
    }

    (slice s, _) = info.udict_get?(10, e);
    int key = s.preload_uint(30);
    return (key / 961 / 961, key / 961 % 961, key % 961, ans);
}