#include "imports/stdlib.fc";

forall X -> tuple set_at(tuple t, X value, int index) asm "SETINDEXVAR";
forall X -> (tuple, ()) ~set_at(tuple t, X value, int index) asm "SETINDEXVAR";

() recv_internal() impure {
    
}

tuple push(tuple maze, tuple info, int i, int j, int key, int ni, int nj) inline {
    int x = maze.at(ni).at(nj);
    if (x == "?"u) {
        key += 961;
    } elseif (x == "X"u) {
        key += 961 * 961;
    }
    int oldkey = info.at(ni).at(nj).at(0);
    if (key < oldkey) {
        info~set_at(info.at(ni).set_at(triple(key, i, j), nj), ni);
    }
    return info;
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    ;;set_gas_limit(10000000000);
    tuple info = empty_tuple();
    tuple vis = empty_tuple();
    int si = 0;
    int sj = 0;
    int i = 0;
    while (i < n) {
        tuple maze_row = maze.at(i);
        tuple info_row = empty_tuple();
        tuple vis_row = empty_tuple();
        int j = 0;
        while (j < m) {
            int x = maze_row.at(j);
            if (x == "E"u) {
                si = i;
                sj = j;
                info_row~tpush(single(0));
            } else {
                info_row~tpush(single(887503681));
            }
            vis_row~tpush(false);
            j += 1;
        }
        info~tpush(info_row);
        vis~tpush(vis_row);
        i += 1;
    }
    
    int i = 0;
    int j = 0;
    do {
        int key = 887503681;
        int xi = 0;
        while (xi < n) {
            int xj = 0;
            while (xj < m) {
                ifnot (vis.at(xi).at(xj)) {
                    int xkey = info.at(xi).at(xj).at(0);
                    if (xkey < key) {
                        key = xkey;
                        i = xi;
                        j = xj;
                    }
                }
                xj += 1;
            }
            xi += 1;
        }
        vis~set_at(vis.at(i).set_at(true, j), i);
        key += 1;

        if (i > 0) {
            if (j > 0) {
                info = push(maze, info, i, j, key, i - 1, j - 1);
            }
            info = push(maze, info, i, j, key, i - 1, j);
            if (j + 1 < m) {
                info = push(maze, info, i, j, key, i - 1, j + 1);
            }
        }
        if (j > 0) {
            info = push(maze, info, i, j, key, i, j - 1);
        }
        if (j + 1 < m) {
            info = push(maze, info, i, j, key, i, j + 1);
        }
        if (i + 1 < n) {
            if (j > 0) {
                info = push(maze, info, i, j, key, i + 1, j - 1);
            }
            info = push(maze, info, i, j, key, i + 1, j);
            if (j + 1 < m) {
                info = push(maze, info, i, j, key, i + 1, j + 1);
            }
        }
    } until (maze.at(i).at(j) == "S"u);

    (int key, i, j) = info.at(i).at(j).untriple();
    while (maze.at(i).at(j) != "E"u) {
        maze~set_at(maze.at(i).set_at("!"u, j), i);
        (_, i, j) = info.at(i).at(j).untriple();
    };

    return (key / 923521, key / 961 % 961, key % 961, maze);
}