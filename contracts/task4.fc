#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";
forall X -> (tuple, ()) set_at(tuple t, X value, int index) asm "SETINDEXVAR";

() recv_internal() impure {
    
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    tuple info = empty_tuple();
    int si = 0;
    int sj = 0;
    int ei = 0;
    int ej = 0;
    int i = 0;
    while (i < n) {
        tuple maze_row = maze.at(i);
        tuple info_row = empty_tuple();
        int j = 0;
        while (j < m) {
            int x = maze_row.at(j);
            if (x == "S"u) {
                si = i;
                sj = j;
                info_row~tpush(begin_cell().store_uint(0, 20).end_cell().begin_parse());
            } else {
                if (x == "E"u) {
                    ei = i;
                    ej = j;
                }
                info_row~tpush(begin_cell().store_uint(0, 10).store_uint(961, 10).end_cell().begin_parse());
            }
            j += 1;
        }
        info~tpush(info_row);
        i += 1;
    }
    
    tuple list = cons(tuple4(si, sj, 0, 0), null());

    tuple deltas = to_tuple([[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]);
    do {
        tuple new_list = null();
        do {
            (int i, int j, int k, int l) = list~list_next().untuple4();
            slice s = info.at(i).at(j);
            int sup = s~load_uint(10);
            int obs = s.preload_uint(10);

            if ((k == sup) & (l == obs)) {
                int idx = 0;
                while (idx < 8) {
                    (int di, int dj) = deltas.at(idx).unpair();
                    int ni = i + di;
                    int nj = j + dj;
                    if ((ni >= 0) & (ni < n) & (nj >= 0) & (nj < m)) {
                        int x = maze.at(ni).at(nj);
                        int nk = k;
                        int nl = l;
                        if (x == "?"u) {
                            nk += 1;
                        } elseif (x == "X"u) {
                            nl += 1;
                        }
                        int index = ni * 31 + nj;
                        slice s = info.at(ni).at(nj);
                        int sup = s~load_uint(10);
                        int obs = s.preload_uint(10);
                        if ((nl < obs) | ((nl == obs) & (nk < sup))) {
                            new_list = cons(tuple4(ni, nj, nk, nl), new_list);
                            tuple info_row = info.at(ni);
                            info_row~set_at(begin_cell().store_uint(nk, 10).store_uint(nl, 10).store_uint(i, 5).store_uint(j, 5).end_cell().begin_parse(), nj);
                            info~set_at(info_row, ni);
                        }
                    }
                    idx += 1;
                }
            }
        } until (list.null?());
        list = new_list;
    } until (list.null?());

    slice s = info.at(ei).at(ej);
    int sup = s~load_uint(10);
    int obs = s~load_uint(10);
    int i = s~load_uint(5);
    int j = s.preload_uint(5);
    
    int length = 1;
    while (maze.at(i).at(j) != "S"u) {
        tuple maze_row = maze.at(i);
        maze_row~set_at("!"u, j);
        maze~set_at(maze_row, i);

        slice s = info.at(i).at(j);
        s~skip_bits(20);
        i = s~load_uint(5);
        j = s.preload_uint(5);

        length += 1;
    };

    return (obs, sup, length, maze);
}