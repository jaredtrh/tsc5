#include "imports/stdlib.fc";

forall X -> (tuple) to_tuple (X x) asm "NOP";

() recv_internal() impure {
    
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    cell info = new_dict();
    int si = 0;
    int sj = 0;
    int ei = 0;
    int ej = 0;
    int i = 0;
    while (i < n) {
        tuple row = maze.at(i);
        int j = 0;
        while (j < m) {
            info~udict_set_builder(10, i * 31 + j, begin_cell().store_uint(31 * 31, 30));
            int x = row.at(j);
            if (x == "S"u) {
                si = i;
                sj = j;
            } elseif (x == "E"u) {
                ei = i;
                ej = j;
            }
            j += 1;
        }
        i += 1;
    }

    tuple deltas = to_tuple([[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]);
    do {
        int min_i = 0;
        int min_j = 0;
        int min_len = 0;
        int min_k = 0;
        int min_l = 31 * 31;
        int i = 0;
        while (i < n) {
            int j = 0;
            while (j < m) {
                (slice s, _) = info.udict_get?(10, i * 31 + j);
                int len = s~load_uint(10);
                int k = s~load_uint(10);
                int l = s.preload_uint(10);
                if ((l < min_l) | ((l == min_l) & ((k < min_k) | ((k == min_k) & (len < min_len))))) {
                    min_i = i;
                    min_j = j;
                    min_len = len;
                    min_k = k;
                    min_l = l;
                }
                j += 1;
            }
            i += 1;
        }
        
        int idx = 0;
        while (idx < 8) {
            (int di, int dj) = deltas.at(idx).unpair();
            int ni = min_i + di;
            int nj = min_j + dj;
            if ((ni >= 0) & (ni < n) & (nj >= 0) & (nj < m)) {
                int x = maze.at(ni).at(nj);
                int nlen = min_len + 1;
                int nk = min_k;
                int nl = min_l;
                if (x == "?"u) {
                    nk += 1;
                } elseif (x == "X"u) {
                    nl += 1;
                }
                int index = ni * 31 + nj;
                (slice s, int success) = info.udict_get?(10, index);
                int flag = 0;
                if (success) {
                    int len = s~load_uint(10);
                    int sup = s~load_uint(10);
                    int obs = s.preload_uint(10);
                    flag = (nl < obs) | ((nl == obs) & ((nk < sup) | ((nk == sup) & (nlen < len))));
                } else {
                    flag = -1;
                }
                if (flag) {
                    info~udict_set_builder(10, index,
                        begin_cell()
                            .store_uint(nlen, 10)
                            .store_uint(nk, 10)
                            .store_uint(nl, 10)
                            .store_uint(min_i, 5)
                            .store_uint(min_j, 5));
                }
            }
            idx += 1;
        }
    } until (list.null?());

    cell ans_dict = new_dict();

    int i = ei;
    int j = ej;
    int length = 0;
    do {
        ans_dict~udict_set_builder(10, i * 31 + j, begin_cell());

        (slice s, _) = info.udict_get?(10, i * 31 + j);
        s~skip_bits(30);
        i = s~load_uint(5);
        j = s.preload_uint(5);

        length += 1;
    } until (maze.at(i).at(j) == "S"u);
    ans_dict~udict_delete?(10, ei * 31 + ej);

    tuple ans = empty_tuple();
    int i = 0;
    while (i < n) {
        tuple maze_row = maze.at(i);
        tuple row = empty_tuple();
        int j = 0;
        while (j < m) {
            (_, int success) = ans_dict.udict_get?(10, i * 31 + j);
            row~tpush(success ? "!"u : maze_row.at(j));
            j += 1;
        }
        ans~tpush(row);
        i += 1;
    }

    (slice s, _) = info.udict_get?(10, ei * 31 + ej);
    int length = s~load_uint(10);
    int sup = s~load_uint(10);
    int obs = s.preload_uint(10);
    return (obs, sup, length, ans);
}